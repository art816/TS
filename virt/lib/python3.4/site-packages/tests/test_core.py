#!/usr/bin/env python3

# This is proprietary software.
# part of cluster monitoring project.
# PEP8 code style used, python version 3
#
# authors: dmitry khodakov <dmitryhd@gmail.com>

# pylint: disable=too-few-public-methods, protected-access

""" General Unit test module. """

import copy
import unittest
import datetime
from nose.plugins.attrib import attr
import time

import nms.utility as utility
import nms.core.nodes_test as nodes_test
from nms.core.download import DownloadManager
from nms.core.parameters import Parameter, parameters
from nms.core.devices import Device, GeneralDevice
from nms.core.context import ContextCreator
from nms.nmsconfig.param_group_config import PARAMETER_LISTS
import nms.core.bx_interface as bx

import nms.core.parameters as pars


class TestParameter(unittest.TestCase):
    """ Parameter tests. """

    @classmethod
    def setUpClass(cls):
        test_params = ['memTotalReal', 'memOccupiedReal', 'memCachedReal',
                       'memFreePercent', 'PowerConsumpted', 'PduPowerUsed',
                       'online', 'Phase1Current']
        cls.test_device = Device('testDevice', full_name='', protocol='snmp',
                                 param_name_list=test_params)

        cls.test_device.params_dict['memTotalReal'].value = 1000
        cls.test_device.params_dict['memOccupiedReal'].value = 600
        cls.test_device.params_dict['memCachedReal'].value = 100
        cls.expect_mem = 50.0

        cls.test_device.params_dict['PowerConsumpted'].value = 5
        cls.expect_power = 220.0 * 5

        cls.test_device.calculate_parameters()

    def test_eq(self):
        """ TestParameter: Comparison of parameters. """
        name_1 = PARAMETER_LISTS['ServerParamList'][0]
        name_2 = PARAMETER_LISTS['ServerParamList'][1]
        self.assertNotEqual(parameters[name_1], parameters[name_2])
        self.assertNotEqual(parameters[name_1], 12)
        par_1 = copy.copy(parameters[name_1])
        par_2 = copy.copy(parameters[name_1])
        self.assertEqual(par_1, par_2)

    def test_calculated_parameter(self):
        """ TestParameter: Param complex formula works. """
        test_val = self.test_device.params_dict['memFreePercent'].value
        self.assertEqual(test_val, self.expect_mem)

    def test_calculated_parameter_const(self):
        """ TestParameter: Param which is = a * const_value works. """
        test_val = self.test_device.params_dict['PduPowerUsed'].value
        self.assertEqual(test_val, self.expect_power)

    def test_parameter_conversion(self):
        """ TestParameter: Value should always be stored in right type. """
        # Int type
        int_par = Parameter('intpar', '', '', 'int', '', '', '')
        int_par.value = '10'
        self.assertEqual(int_par.value, 10)
        # Float type
        float_par = Parameter('intpar', '', '', 'float', '', '', '')
        float_par.value = '0.5'
        self.assertEqual(float_par.value, 0.5)
        #  type
        str_par = Parameter('strpar', '', '', 'str', '', '', '')
        str_par.value = '0.5'
        self.assertEqual(str_par.value, '0.5')

    def test_calculated_speed(self):
        """ TestSwitchSpeed: Get speed for switch.
            After function calculate_parameters
            old_octet_switch == curr_octet_switch"""

        parameters['curr_octet_switch'] = pars.Parameter('curr_octet_switch',
                                                         '', '', 'int',
                                                         '', '', '')
        parameters['old_octet_switch'] = pars.Parameter('old_octet_switch',
                                                        '', '', 'int',
                                                        '', '', '')
        parameters['last_time_switch'] = pars.Parameter('last_time_switch',
                                                        '', '', 'float',
                                                        '', '', '')
        parameters['speed_switch'] = pars.CalculatedParameter('speed_switch',
                                                              '', '', 'float',
                                                              '', '', '',
                                                              is_calculated=True)
        parameters['speed_switch'].list_of_function_to_calculate = '-'
        parameters['speed_switch'].names_of_params_to_calculate =\
                ['curr_octet_switch', 'old_octet_switch', 'last_time_switch']
        param_name_list = ['curr_octet_switch', 'last_time_switch',
                           'speed_switch', 'old_octet_switch']
        self.test_switch = Device('testSwitch', '', '', param_name_list)
        self.test_switch.params_dict['curr_octet_switch'].value = 1000
        self.test_switch.calculate_parameters()
        curr_octet_switch = 200000
        self.test_switch.params_dict['curr_octet_switch'].value =\
                curr_octet_switch
        old_octet_switch = self.test_switch.params_dict['old_octet_switch'].value
        time_init = int(time.time())
        self.test_switch.params_dict['last_time_switch'].value = time_init
        time_diff = 1
        import unittest.mock as mock
        with mock.patch('time.time') as time_mock:
            time_mock.return_value = time_init + time_diff
            self.test_switch.calculate_parameters()

        self.assertEqual(self.test_switch.params_dict['old_octet_switch'].value,
                         self.test_switch.params_dict['curr_octet_switch'].value)
        self.assertAlmostEqual(self.test_switch.params_dict['speed_switch'].value,
                               (curr_octet_switch - old_octet_switch)/
                               time_diff*8/1024/1024, places=2)

        #self.test_switch.params_dict['speed'].value = 100
        #self.expect_mem = 50.0


    def test_readable_values(self):
        """ TestParameter: Check if we can convert 4 to 'not accessible.' """
        enum_par = Parameter('enumpar', '', '', 'int', '', '', '')
        enum_par.is_enum = True
        enum_par.enum = {0: 'low', 1: 'high'}
        self.assertEqual(enum_par.make_value_readable(0), enum_par.enum[0])
        self.assertEqual(enum_par.make_value_readable(1), enum_par.enum[1])
        self.assertEqual(enum_par.make_value_readable(100), 100)


class TestDevices(unittest.TestCase):
    """ Here we try to download parameters in test mode for all devices. """

    def check_device_virtual(self, dev_name, context):
        """ TestDevices: Check when device not connected. """
        dev = context.devices[dev_name]
        dev.is_online = True
        dmanager = DownloadManager(is_testmode=True)
        value = 1
        for param in dev.params_dict.values():
            if param.is_calculated:
                continue
            param.value = None
            dmanager.download(dev, param, value)
            expected_val = str(value) if param._type == 'str' else value
            self.assertEqual(param.value, expected_val)
            value += 1

    def test_device_download(self):
        """ TestDevices: devices download check. """
        context = ContextCreator('localhost').from_file()
        for device_name in context.devices.keys():
            self.check_device_virtual(device_name, context)


class TestGeneralDevice(unittest.TestCase):
    """ GeneralDevice class test. """

    def test_init(self):
        """ TestGeneralDevice: General device creation. """
        context = ContextCreator('localhost').from_file()
        general_device = GeneralDevice(
            'sum_device', '', 'dev_description',
            ['laptop', 'laptop'], context)
        self.assertEqual(general_device.name, 'sum_device')
        self.assertEqual(general_device.description, 'dev_description')


class TestContext(unittest.TestCase):
    """ Test that context manager holds devices, general devices and params. """

    def check_context(self, context):
        """ Raise assert if context is invalid. """
        self.assertTrue(context.devices)
        self.assertTrue(context.general_devices)
        self.assertTrue(context.parameters)
        self.assertTrue(context.device_containers)

    def test_localhost_context(self):
        """ TestContext: create localhost context. """
        context_creator = ContextCreator('localhost')
        context = context_creator.from_file()
        self.check_context(context)

    def test_burka_context(self):
        """ TestContext: create burka context. """
        context_creator = ContextCreator('burka')
        context = context_creator.from_file()
        self.check_context(context)

    def test_bussol_context(self):
        """ TestContext: create bussol context. """
        context_creator = ContextCreator('bussol')
        context = context_creator.from_file()
        self.check_context(context)

    @attr('now')
    def test_buer_context(self):
        """ TestContext: create buer context. """
        context_creator = ContextCreator('buer')
        context = context_creator.from_file()
        self.check_context(context)
        self.assertTrue("switch" in context.devices)
        self.assertTrue("CpuSwitch" in context.parameters)
        self.assertTrue("switch" in context.general_devices)
        self.assertTrue("raid" in context.devices)
        self.assertTrue("OnBoardTemp1_CtrlA1" in context.parameters)
        self.assertTrue("raid" in context.general_devices)
        self.assertGreater(len(context.general_devices), 4)
        self.assertTrue('rmu1' in context.general_devices)
        self.assertTrue('pdu1' in context.general_devices)
        self.assertTrue('MonitoringServer' in context.general_devices)
        self.assertTrue('ServerRaspred' in context.general_devices)
        self.assertTrue('FileServer' in context.general_devices)


class TestUtility(unittest.TestCase):
    """ Check base common functions. """

    def test_run_command_timeout(self):
        """ TestUtility: Run command with timeout test. """
        start = datetime.datetime.now()
        utility.run_command_with_timeout(['sleep', '5'], 1.0)
        total_time = datetime.datetime.now() - start
        self.assertLess(total_time, datetime.timedelta(seconds=1.5))
        start = datetime.datetime.now()
        utility.run_command_with_timeout(['sleep', '1'], 1.5)
        total_time = datetime.datetime.now() - start
        self.assertGreater(total_time, datetime.timedelta(seconds=0.9))

    def test_ping(self):
        """ TestUtility: Ping test. """
        self.assertTrue(utility.ping("127.0.0.1"))
        self.assertFalse(utility.ping("127.0.0.270"))

    def test_group_ping(self):
        """ TestUtility: Group ping test. """
        context = ContextCreator('localhost').from_file()
        results = utility.group_ping(context.devices.values())
        self.assertTrue(True in results)  # 127.0.0.1 is always up!

    @staticmethod
    def test_run_multithread():
        """ TestUtility: Test run in parallel (on sleep command). """
        args = []
        functions = []
        for sleep_time in ['1', '2', '3', '4']:
            args.append([['sleep', sleep_time], 2.0])
            functions.append(utility.run_command_with_timeout)
            utility.run_in_parallel(functions, args)


class TestNodesTest(unittest.TestCase):
    """ Initiate tests for dhcp state, mount state and gpu state. """


    @staticmethod
    def test_dhcp():
        """ TestNodesTest: Is all present to check dhcp state? """
        nodes_test.check_dhcp()

    @unittest.skip("tmp")
    @staticmethod
    def test_mount():
        """ TestNodesTest: Test if any problems with nfs mounting check. """
        context = ContextCreator('localhost').from_file()
        nodes_test.check_mount_point(context)

    @staticmethod
    @unittest.skip('Refactor it, takes too long.')
    def test_nodes():
        """ TestNodesTest: Test gpus and ping. """
        context = ContextCreator('localhost').from_file()
        nodes_test.nodes_check(context)


class TestBxInterface(unittest.TestCase):
    """docstring for TestBxInterface"""

    def test_bx_info_full(self):
        """ TestBxInterface: bx info with one job. """
        bx_info_raw = ("job=37.1 username=so5 GPU_count=48"
                       " exec_time=5 estimated_end=19:45")
        bx_info = bx.parse_bx_info(bx_info_raw)
        self.assertTrue(bx_info['has_job'])
        self.assertEqual(bx_info['jobs'][0]['job'], '37.1')
        self.assertEqual(bx_info['jobs'][0]['username'], "so5")
        self.assertEqual(bx_info['jobs'][0]['GPU_count'], '48')
        self.assertEqual(bx_info['jobs'][0]['exec_time'], '5')
        self.assertEqual(bx_info['jobs'][0]['estimated_end'], "19:45")

    def test_bx_info_full_two(self):
        """ TestBxInterface: bx info with two jobs. """
        bx_info_raw = ("job=37.1 username=so5 GPU_count=48"
                       " exec_time=5 estimated_end=19:45\n"
                       "job=40.1 username=so6 GPU_count=42"
                       " exec_time=6 estimated_end=20:45\n")
        bx_info = bx.parse_bx_info(bx_info_raw)
        self.assertTrue(bx_info['has_job'])
        jobs = bx_info['jobs']
        self.assertTrue(jobs[0])
        self.assertEqual(jobs[0]['job'], '37.1')
        self.assertEqual(jobs[0]['username'], "so5")
        self.assertEqual(jobs[0]['GPU_count'], '48')
        self.assertEqual(jobs[0]['exec_time'], '5')
        self.assertEqual(jobs[0]['estimated_end'], "19:45")

        self.assertTrue(jobs[1])
        self.assertEqual(jobs[1]['job'], '40.1')
        self.assertEqual(jobs[1]['username'], "so6")
        self.assertEqual(jobs[1]['GPU_count'], '42')
        self.assertEqual(jobs[1]['exec_time'], '6')
        self.assertEqual(jobs[1]['estimated_end'], "20:45")

    def test_bx_info_full(self):
        """ TestBxInterface: bx info without jobs. """
        bx_info_raw = "No jobs executed"
        bx_info = bx.parse_bx_info(bx_info_raw)
        self.assertFalse(bx_info['has_job'])

    def test_bx_schedule_full(self):
        """ TestBxInterface: bx schedule with job. """
        bx_sch_raw = (
            "job=38.1 username=so5 GPU_count=48 estimated_start_in=b~4 time_in=19:42")
        bx_sch = bx.parse_bx_schedule(bx_sch_raw)
        self.assertTrue(bx_sch['has_job'])
        self.assertEqual(bx_sch['jobs'][0]['job'], '38.1')
        self.assertEqual(bx_sch['jobs'][0]['username'], "so5")
        self.assertEqual(bx_sch['jobs'][0]['GPU_count'], '48')
        self.assertEqual(bx_sch['jobs'][0]['until_start'], '4')
        self.assertEqual(bx_sch['jobs'][0]['reason'],
                         bx.WHY_NOT_RUN['b'])
        self.assertEqual(bx_sch['jobs'][0]['time_in'], "19:42")

    def test_bx_schedule_empty(self):
        """ TestBxInterface: bx sch with jobs. """
        bx_sch_raw = "Job queue is empty"
        bx_sch = bx.parse_bx_schedule(bx_sch_raw)
        self.assertFalse(bx_sch['has_job'])

    def test_bx_so_empty(self):
        """ TestBxInterface: bx so list without so. """
        bx_so_list = "No so"
        bx_so = bx.parse_bx_so_list(bx_so_list)
        self.assertFalse(bx_so['has_so'])

    def test_bx_so_couple(self):
        """ TestBxInterface: bx so list with 2 so. """
        bx_so_list = "1. ('rar', 40, 4)\n 2. ('zip', 400, 2)\n"
        bx_so = bx.parse_bx_so_list(bx_so_list)
        self.assertTrue(bx_so['has_so'])
        self.assertEqual(bx_so['so'], [
            {'id': '1', 'name': 'rar', 'num1': '40', 'priority': '4'},
            {'id': '2', 'name': 'zip', 'num1': '400', 'priority': '2'}])

    def test_bx_status(self):
        """ TestBxInterface: bx status. """
        bx_status_raw = "Free: 5 proc.  Available: 48"
        bx_status = bx.parse_bx_status(bx_status_raw)
        self.assertEqual(bx_status['free'], '5')
        self.assertEqual(bx_status['available'], '48')

if __name__ == '__main__':
    unittest.main()
