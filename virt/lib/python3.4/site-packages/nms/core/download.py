#!/usr/bin/env python3

# This is proprietary software.
# part of cluster monitoring project.
# PEP8 code style used, python version 3
#
# authors: dmitry khodakov <dmitryhd@gmail.com>
#
# pylint: disable=C0103, R0201, W0613, E0202, logging-format-interpolation


""" Module containing Download Manager class
    for get data by snmp, ipmi, ssh and telnet.
"""

import copy
import re

import nms.config as config
import nms.utility as utility


class DownloadManager(object):
    """ Object to manage all downloads. """
    SNMP_COMMANDS = {'v1': ["snmpget", "-On", "-v", "1", "-Cf", "-c",
                            "public"],
                     'v2c': ["snmpget", "-On", "-v", "2c", "-Cf", "-c",
                             "public"],
                     'v3': ["snmpget", "-On", "-v", "3", "-Cf", "-c",
                            "public", "-u", "snmpuser"],
                     'set': ["snmpset", "-v1", "-cpublic"]}
    IPMI_COMMANDS = {'bmc': ["ipmitool", "-I", "lan", "-U", "admin", "-P",
                             "admin", "sensor"],
                     'tyan': ["ipmitool", "-I", "lan", "-U", "root", "-P",
                              "superuser", "sensor"]}
    SNMP_TIMEOUT = 4.0
    IPMI_TIMEOUT = 2.0
    snmpset_types = {'i': int, "F": float}

    def __init__(self, is_testmode=False):
        self.SNMP_TIMEOUT = config.SNMP_TIMEOUT
        self.IPMI_TIMEOUT = config.IPMI_TIMEOUT
        self.is_testmode = is_testmode
        if is_testmode:
            self.snmp_get = self.snmp_get_test
            self.ipmi_get = self.ipmi_get_test

    @staticmethod
    def parse_output(reg_expression, string):
        """ static function to parse string from <protocol>get
          @ return value from string or None
        """
        try:
            res = re.search(reg_expression, string).groups()[0].strip()
        except (re.error, AttributeError, TypeError):
            return None
        if not res:
            res = None
        return res

    def download(self, dev, parameter, desired=None):
        """ Get multiple parameters. """
        if parameter.protocol == 'snmp':
            self.snmp_get(dev.ip_addr, parameter, dev.protocol_version,
                          desired)
        elif parameter.protocol == 'ipmi':
            self.ipmi_get(dev.ip_addr, parameter, dev.protocol_version,
                          desired)
        elif parameter.protocol == 'icmp':
            self.icmp_get_function(dev.ip_addr, parameter, desired)
        elif parameter.protocol == 'calc':
            return

    def download_multiple_params(self, dev, params):
        """ Get multiple parameters.  """
        if dev.protocol == 'snmp':
            return self.snmp_get_multiple(dev, params)
        elif dev.protocol == 'ipmi':
            return self.ipmi_get_multiple(dev, params)

    def snmp_get_multiple(self, dev, parameters):
        """ Get multiple parameters. """
        ip_addr = dev.ip_addr
        type_ = dev.protocol_version
        command = self.SNMP_COMMANDS[type_] + [ip_addr]
        snmp_params = [par for par in parameters
                       if par.protocol == 'snmp' and not par.is_calculated]
        if len(snmp_params) > 80:
            third = int(len(snmp_params)/3)
            snmp1 = snmp_params[:third]
            snmp2 = snmp_params[third:2*third]
            snmp3 = snmp_params[2*third:]
            res1 = self.snmp_get_multiple(dev, snmp1)
            res2 = self.snmp_get_multiple(dev, snmp2)
            res3 = self.snmp_get_multiple(dev, snmp3)
            params = []
            params.extend(res1[1])
            params.extend(res2[1])
            params.extend(res3[1])
            return (dev.name, params)
        for parameter in snmp_params:
            command.append(parameter.identifier)
        output = utility.run_command_with_timeout(command, self.SNMP_TIMEOUT)
        if not output:
            utility.log_color('FAILED: ' + ' '.join(command), 'red', 'warning')
            return
        for param in snmp_params:
            expr = r'{}\s+=\s+\w+{}'.format(param.identifier,
                                            param.reg_expression)
            try:
                res = re.search(expr, output).groups()[0].strip()
                param.value = res

            except (re.error, AttributeError, TypeError, ValueError):
                utility.log_color(
                    'parsing error. dev={}, name={}, par_id={}'.format(
                        ip_addr, param.name, param.identifier), 'red',
                    'warning')
        return (dev.name, snmp_params)

    def ipmi_get_multiple(self, dev, parameters):
        """ Get multiple parameters. """
        ip_addr = dev.ip_addr
        type_ = dev.protocol_version
        ipmi_params = [par for par in parameters
                       if par.protocol == 'ipmi' and not par.is_calculated]
        command = copy.copy(self.IPMI_COMMANDS[type_])
        command.insert(3, "-H")
        command.insert(4, ip_addr)
        output = utility.run_command_with_timeout(command, self.IPMI_TIMEOUT)
        if not output:
            utility.log_color('FAILED: ' + ' '.join(command), 'red', 'warning')
            return
        if re.match(r'Unable to set', output):
            utility.log_color('FAILED: ' + ' '.join(command), 'red', 'warning')
            return
        for par in ipmi_params:
            par.value = self.parse_output(par.reg_expression,
                                          output)
        return (dev.name, ipmi_params)

    @staticmethod
    def snmp_set_function(ip_addr, oid, type_, value,
                          snmp_command=SNMP_COMMANDS['set']):
        """ Normally get snmpget and get info from ip
            return: utf8 string with results or empty string.
        """
        if type_ in DownloadManager.snmpset_types.keys():
            try:
                DownloadManager.snmpset_types[type_](value)
            except ValueError:
                return None
        command = snmp_command + [ip_addr, oid, type_, value]
        output = utility.run_command_with_timeout(command,
                                                  DownloadManager.SNMP_TIMEOUT)
        return output

    @staticmethod
    def snmp_get_function(ip_addr, oid,
                          snmp_command=SNMP_COMMANDS['v1']):
        """ Normally get snmpget and get info from ip
            return: utf8 string with results or empty string.
        """
        command = snmp_command + [ip_addr, oid]
        output = utility.run_command_with_timeout(
            command, DownloadManager.SNMP_TIMEOUT)
        return output

    def snmp_get_test(self, ip_addr, parameter, type_='v1', desired=None):
        """ Test version of casual function. """
        parameter.value = desired

    def icmp_get_function(self, ip_addr, parameter, desired=None):
        """ Casual function. """
        if not desired:
            parameter.value = utility.ping(ip_addr)
        else:
            parameter.value = desired

    def snmp_get(self, ip_addr, parameter, type_='v1', desired=None):
        """ Normally get snmpget and get info from ip
            return: utf8 string with results or None.
        """
        if desired is not None:
            parameter.value = desired
            return
        command = self.SNMP_COMMANDS[type_] + [ip_addr, parameter.identifier]
        output = utility.run_command_with_timeout(command, self.SNMP_TIMEOUT)
        if not output:
            utility.log_color('FAILED: ' + ' '.join(command), 'red', 'warning')
        parameter.value = self.parse_output(parameter.reg_expression,
                                            output)

    def ipmi_get_test(self, ip_addr, parameter, type_='v1', desired=None):
        """ Test version of casual function. """
        parameter.value = desired

    def ipmi_get(self, ip_addr, parameter, type_='v1', desired=None):
        """ Normally get ipmiget and get info from ip
            return: utf8 string with results or None """
        if desired is not None:
            parameter.value = desired
            return
        command = copy.copy(self.IPMI_COMMANDS[type_])
        command.insert(3, "-H")
        command.insert(4, ip_addr)
        output = utility.run_command_with_timeout(command, self.IPMI_TIMEOUT)
        if re.match(r'Unable to set', output):
            utility.log_color('FAILED: ' + ' '.join(command), 'red', 'warning')
            return None
        parameter.value = self.parse_output(parameter.reg_expression,
                                            output)
