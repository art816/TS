#!/usr/bin/env python3

# This is proprietary software.
# part of cluster monitoring project.
# PEP8 code style used, python version 3
#
# authors: dmitry khodakov <dmitryhd@gmail.com>

# pylint: disable=too-few-public-methods, too-many-instance-attributes
# pylint: disable=too-many-arguments, too-many-locals, star-args, eval-used

""" Module containing class Parameter and global dictionary parameters. """

from operator import attrgetter
import time

import nms.utility as utility
import nms.config as cfg
from nms.nmsconfig.param_config import param_init

LOG = utility.LogCreator().get_log()


class Boundaries(object):
    """ Class for representing parameter limits min, max, and warning levels.
        Need for passing boudary to parameter class.
    """
    # TODO: collections.namedtuple here
    def __init__(self, err_min=None, warn_min=None, warn_max=None,
                 err_max=None):
        self.err_min = err_min
        self.warn_min = warn_min
        self.warn_max = warn_max
        self.err_max = err_max

    def __eq__(self, other):
        """ Method compares two parameters. Returns True if all fields of
            parameters are equal.
        """
        if isinstance(other, self.__class__):
            return self.__dict__ == other.__dict__
        else:
            return False

    def __repr__(self):
        """ Print short version of boundaries. """
        return '[{}, {}, {}, {}]'.format(self.err_min, self.warn_min,
                                         self.warn_max, self.err_max)


class Parameter(object):
    """ Prameter contain infrormation about basic collectable piece of
        information about device state.
    """
    def __init__(self, name, full_name, desc, _type, identifier, protocol,
                 units, reg_expression=cfg.PARAM_DEFAULT_REGEXP,
                 value_boundaries=(None, None, None, None),
                 visible=True, vrange=None,
                 value_mult=None, is_calculated=False,
                 collect_interval=cfg.DEFAULT_COLLECT_INTERVAL,
                 significant_digits=cfg.DEFAULT_SIGNIFICANT_DIGITS):
        self.name = name
        self.full_name = full_name
        self.desc = desc
        self._type = _type
        self.identifier = identifier  # snmp oid for snmp or name for ipmi
        self.protocol = protocol
        self.units = units
        if reg_expression == cfg.PARAM_DEFAULT_REGEXP:
            self.reg_expression = cfg.PARAM_REGEXPS[_type]
        else:
            self.reg_expression = reg_expression
        self.value = None
        self.boundaries = Boundaries(*value_boundaries)
        self.is_calculated = is_calculated
        self.visible = visible  # if this param will be showed in web form.
        self.vrange = vrange if vrange else [None, None]
        self.value_mult = value_mult
        self.do_have_alerts = False
        self.last_collected = 0 # int time
        self.collect_interval = collect_interval
        self.significant_digits = significant_digits
        self.is_enum = False
        self.enum = dict()

    def __setattr__(self, key, value):
        """ We must preserve parameter type. """
        if key == 'value' and value is not None:
            if self._type == 'int':
                # Must convert to float first, because, we cant convert
                # string like '1.0' to int directly.
                self.__dict__[key] = int(float(value))
            elif self._type == 'float':
                new_value = round(float(value), self.significant_digits)
                self.__dict__[key] = new_value
            else:
                self.__dict__[key] = str(value)
        else:
            self.__dict__[key] = value

    def __repr__(self):
        """ Print short version of parameter """
        return self.name + ':' +str(self.value)

    def __eq__(self, other):
        """ Method compares two parameters.
            Returns True if all fields of parameters are equal.
        """
        if isinstance(other, self.__class__):
            return self.__dict__ == other.__dict__
        else:
            return False

    def __ne__(self, other):
        """ Method compares two parameters.
            Return True if not all fields of parameters are equal.
        """
        return not self.__eq__(other)

    @staticmethod
    def get_plot_extreme(vrange, err, warn):
        """ Return range. """
        if vrange is not None:
            return vrange
        if err is not None:
            return err
        if warn is not None:
            return warn
        return None

    def get_min_y(self):
        """ Return min y. """
        return self.get_plot_extreme(self.vrange[0], self.boundaries.err_min,
                                     self.boundaries.warn_min)

    def get_max_y(self):
        """ Return max y. """
        return self.get_plot_extreme(self.vrange[1], self.boundaries.err_max,
                                     self.boundaries.warn_max)

    def make_value_readable(self, value):
        """ Lookup inside of enum and return string value of given int value.
        """
        if self.is_enum and value in self.enum:
            return self.enum[value]
        else:
            return value


class CalculatedParameter(Parameter):
    """ Subclass of parameter, which is not meant to be downloaded by network.
        Instead it is calculated, using some of downloaded parameter.
        Calculation placed in Device.
    """
    def __init__(self, name, full_name, desc, _type, identifier, protocol,
                 units, reg_expression=cfg.PARAM_DEFAULT_REGEXP,
                 value_boundaries=(None, None, None, None),
                 visible=True, vrange=None,
                 value_mult=None,
                 names_of_params_to_calculate=None,
                 list_of_function_to_calculate=None, calculation_const=1,
                 is_calculated=True):
        super().__init__(name, full_name, desc, _type, identifier, protocol,
                         units, reg_expression,
                         value_boundaries,
                         visible, vrange,
                         value_mult, is_calculated)
        self.calculation_const = calculation_const
        self.list_of_function_to_calculate = list_of_function_to_calculate
        self.names_of_params_to_calculate = names_of_params_to_calculate
        self.params_to_calculate = []

    def link_to_device_to_calculate(self, device):
        """ Call this function to set list of self.params_to_calculate with
            valid parameters of this device. Need to be called for every
            calculated parameter of device.
            Warning: don't use calculated parameters to calculate
            calculated parameters!
        """
        self.params_to_calculate = []
        for param_name in self.names_of_params_to_calculate:
            for parameter in device.params_dict.values():
                if parameter.name == param_name:
                    self.params_to_calculate.append(parameter)

    def calculate(self):
        """ Set value of calculated parameter in according to formula and
            list of params to calculate. Return immediately if function isn't
            calculated.
        """
        (param_old_octet, param_curr_octet) = self.preparation_for_speed_switch()

        current_value = utility.save_float_conversion(
            self.params_to_calculate[0].value)
        for curr_index in range(len(self.list_of_function_to_calculate)):
            val = self.params_to_calculate[curr_index+1].value
            next_arg = utility.save_float_conversion(val)
            eval_expr = 'current_value '
            eval_expr += self.list_of_function_to_calculate[curr_index]
            eval_expr += ' ' + str(next_arg)
            try:
                current_value = eval(eval_expr)
            except (ValueError, TypeError, ZeroDivisionError):
                current_value = None
        self.value = current_value
        if self.value:
            self.value *= self.calculation_const
        self.finalise_for_speed_switch(param_old_octet, param_curr_octet)

    def preparation_for_speed_switch(self):
        """ Only for switch.
            Name last_time_switch, old_octet_switch, curr_octet_switch is
            impotant (Used in buer_context).
            Update self.calculation_const how 1/dt, need for calculate speed.
            Return two parameters with names curr_octet_switch,
            old_octet_switch, need for finalize_for_speed_switch. """
        if 'speed_switch' in self.name:
            for param in self.params_to_calculate:
                if 'last_time_switch' in param.name:
                    try:
                        self.calculation_const = 1.0/(time.time() -  param.value)
                    except (ValueError, TypeError, ZeroDivisionError):
                        self.calculation_const = None
                    param.value = time.time()
                    self.params_to_calculate.remove(param)
                elif 'old_octet_switch' in param.name:
                    param_old_octet = param
                elif 'curr_octet_switch' in param.name:
                    param_curr_octet = param
            return param_old_octet, param_curr_octet
        return None, None

    def finalise_for_speed_switch(self, param_old_octet, param_curr_octet):
        """ Set curr_octet_switch in old_octet_switch.
            Get speed in Mb/s"""
        if 'speed_switch' in self.name:
            param_old_octet.value = param_curr_octet.value
            self.value = self.value * 8 / 1024 / 1024 if self.value is not None else None


class ParameterGroup(object):
    """ Container for group of parameters. Should be used in web interface.
        Delegated to GeneralDevice.
    """
    def __init__(self, name, full_name, par_names):
        self.name = name
        self.full_name = full_name
        self.description = ''
        self.par_names = par_names
        self.par_names.sort()
        self.params = []
        self.par_full_names = {}
        self.do_plot = False
        self.boundaries = Boundaries(None, None, None, None)
        self.miny = None
        self.maxy = None

    def setup(self, parameters):
        """ Setup group. """
        for param_name in parameters:
            if param_name in self.par_names:
                self.params.append(parameters[param_name])
                self.par_full_names[param_name] = parameters[
                    param_name].full_name
        self.params.sort(key=attrgetter('name'))
        if self.params:
            self.miny = self.params[0].get_min_y()
            self.maxy = self.params[0].get_max_y()
            self.boundaries = self.params[0].boundaries


# Global structure, containing all parameters.
# TODO: dispose of global structures.
parameters = {}

def configure_parameters():
    """ Populate glibal parameters. """
    for par_dict in param_init:
        if 'is_calculated' in par_dict and par_dict['is_calculated']:
            parameters[par_dict['name']] = CalculatedParameter(**par_dict)
        else:
            parameters[par_dict['name']] = Parameter(**par_dict)


configure_parameters()
