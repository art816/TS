#!/usr/bin/env python3

# This is proprietary software.
# Part of cluster monitoring project.
# PEP8 codestyle used, python version 3.
#
# authors: artem pilkevich, dmitriy khodakov


"""  This module contain AlertHandler.
     It manages alerts, creates them, delets them.
"""

import operator
import re

from nms.core.database import AlertDataOperator, SystemDataOperator
from nms.core.alerts import Alert, OldAlert
from nms.utility import log_color, to_general_device


class AlertHandler(object):
    """ Manager database. """
    def __init__(self, session_manager):
        self.alert_data_operator = AlertDataOperator(session_manager)
        self.system_db = SystemDataOperator(session_manager) 

    def update_alerts(self, devices):
        """ Return statistic new, kill, update alerts. """
        alert_statistics = dict(kill_alert=0, update_alert=0,
                                new_alert=0, no_changes=0)
        for device in devices:
            for param in device.params_dict.values():
                # we should move alerts to old_alerts.
                # If device is offline, only online param should give an alert.
                if not device.is_online and 'online' not in param.name:
                    continue
                if 'online' in param.name:
                    gdev_name = to_general_device(device.name) 
                    if self.system_db.get_admin_status(gdev_name) == 'off':
                        continue
                    

                level = self.get_alert_level(param.value, param.boundaries)
                current_alert = self.get_alert(device.name, param.name)
                if current_alert:
                    self.alert_data_operator.update_alert(current_alert, level,
                                                          alert_statistics)
                    self.alert_data_operator.kill_alert(current_alert, level,
                                                        alert_statistics)

                elif level and self.do_we_need_to_create_alert(device.name,
                                                               devices):
                    new_alert = Alert(device.name, param.name, level)
                    log_color('creating alert:{}'.format(new_alert),
                              'green', 'debug')
                    self.alert_data_operator.add_alert(new_alert,
                                                       alert_statistics)
        return alert_statistics

    @staticmethod
    def do_we_need_to_create_alert(device_name, devices):
        """ Return True if we need, this is hardware.
            For example, when File server is offline and bmc is online,
            BMC returns 0 as temperatures, that will generate alert, however
            we need to prevent this, when regular device is up - create alerts,
            when down - prevent generating.
        """
        control_servers = ['FileServerBMC', 'MonitoringServerBMC',
                           'ServerRaspredBMC']
        if device_name in control_servers:
            possible_dev_name = re.sub('BMC', '', device_name)
            for device in devices:
                if device.name == possible_dev_name:
                    if device.is_online:
                        return True
                    else:
                        return False
        return True

    def get_alerts(self):
        """ Return list of alerts ordered by start time decreasing. """
        return self.alert_data_operator.get_entries(Alert)

    def get_old_alerts(self):
        """ Return list of alerts ordered by start time decreasing. """
        return self.alert_data_operator.get_entries(OldAlert)

    def get_alerts_by_dev_name(self, dev_name):
        """ Return list of alerts of specific device ordered by start time
            decreasing.
        """
        return self.alert_data_operator.get_entries(
            Alert, {'device_name': dev_name})

    def clear(self):
        """ Delete all current alerts without adding them to old alerts. """
        alerts = self.get_alerts()
        with self.alert_data_operator.sessionmaker() as session:
            for alert in alerts:
                session.delete(alert)

    @staticmethod
    def get_alert_level(value, boundaries):
        """ Return alert level if value is out of boundaries
            Return FALSE otherwise.
        """
        do_have_alert = False
        bound_funcs = {"err_min": "le", "warn_min": "le",
                       "err_max": "ge", "warn_max": "ge"}
        # NB: order of keys important here!
        for level in ['err_min', 'err_max', 'warn_min', 'warn_max']:
            bound_value = getattr(boundaries, level)
            try:
                do_have_alert = getattr(operator, bound_funcs[level])(
                    value, bound_value)
            except TypeError:
                do_have_alert = False
            if do_have_alert:
                break
        return do_have_alert and level

    def get_alert(self, device_name, param_name):
        """ Return alert by device name and parameter name or
            None of no alert present. """
        for alert in self.get_alerts():
            if (alert.device_name == device_name and
                    alert.param_name == param_name):
                return alert

