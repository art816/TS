#!/usr/bin/env python3

# This is proprietary software.
# part of cluster monitoring project.
# PEP8 code style used, python version 3
#
# authors: dmitry khodakov <dmitryhd@gmail.com>

# pylint: disable=R0903, R0902, logging-format-interpolation

""" This module's purpose is to enable and disable power
    on servers by ipmi.
"""

import os
import time
import shlex
from sys import argv
from subprocess import PIPE, Popen
import subprocess
from collections import OrderedDict

import nms.config as cfg
import nms.utility as utility
from nms.core.download import DownloadManager
from nms.nmsconfig.device_config import PDU_OUTLET_NUM, PowerControlledDevices
from nms.nmsconfig.device_config import DEVICE_OUTLETS_MAP, PDU_NUMERATION

LOG = utility.LogCreator().get_log()


class GlobalPowerManager(object):
    """ Power on or off all cluster, except Monitoring Server. """
    def __init__(self, context, system_db=None):
        self.support_servers = ['FileServer', 'ServerRaspred']
        self.node_names = ['node1', 'node2', 'node3', 'node4', 'node5', 'node6']
        self.power = {}
        all_nodes = []
        all_nodes.extend(self.support_servers)
        all_nodes.extend(self.node_names)
        for node_name in all_nodes:
            self.power[node_name] = ServerPowerManager(
                context.general_devices[node_name])
            self.power[node_name].connect_db(system_db)
        self.context = context
        self.LOAD_TIME = 250  # Time to fully load server in seconds.
        self.SHUTDOWN_TIME = 30  # Time to halt operating system in seconds.
        self.FULL_SHUTDOWN_TIME = 200  # Time to full cold shutdown on all nodes in seconds.
    
    def power_on(self):
        utility.log_color('Power on all cluster.', 'yellow', 'warn')
        for node_name in self.support_servers:
            self.power[node_name].power_on()
        time.sleep(self.LOAD_TIME)
        for node_name in self.node_names:
            self.power[node_name].power_on()

    def reboot(self):
        utility.log_color('Reboot all cluster', 'yellow', 'warn')
        self.soft_shutdown()
        time.sleep(self.FULL_SHUTDOWN_TIME)
        self.power_on()

    def soft_shutdown(self):
        utility.log_color('Shutdown all cluster.', 'yellow', 'warn')
        process_runner = utility.ProcessRunner(self.SHUTDOWN_TIME * 2)
        for node_name in self.node_names:
            process_runner.add(self.power[node_name].soft_shutdown, [])
        result = process_runner.run()
        time.sleep(self.SHUTDOWN_TIME)
        process_runner = utility.ProcessRunner(self.SHUTDOWN_TIME * 2)
        for node_name in self.support_servers:
            process_runner.add(self.power[node_name].soft_shutdown, [])
        result = process_runner.run()



class ServerPowerManager(object):
    """docstring for ServerPowerManager"""
    def __init__(self, general_device):
        self.gdevice = general_device
        self.has_ping = False
        self.power_state = False
        self.system_user = 'root'
        self.system_password = '111111'
        gdev_name = general_device.name
        if gdev_name in cfg.CREDENTIALS:
            self.ipmi_user = cfg.CREDENTIALS[gdev_name]['ipmi_user']
            self.ipmi_password = cfg.CREDENTIALS[gdev_name]['ipmi_passwd']
        else:
            self.ipmi_user = 'admin'
            self.ipmi_password = 'admin'
        self.SYSTEMSHUTDOWN_TIMEOUT = 40  # sec to shutdown by ssh
        self.BMC_STARTUP_TIME = 30  # seconds to wait for bmc to start after power is on
        self.pdus = cfg.OUTLETS[general_device.name]
        self.connected_to_db = False
        self.system_db = None

    def check_all(self):
        self.ping()
        self.ipmi_status()

    def ping(self):
        self.has_ping = utility.ping(self.gdevice.ip_addr)
        return self.has_ping

    def ipmi_status(self):
        command = 'ipmitool -I lan -U {} -P {} -H {} power status'.format(
                self.ipmi_user, self.ipmi_password, self.gdevice.ip_addr_bmc)
        try:
            out = self.get_command_output(command)
        except OSError:
            self.power_state = False
            utility.log_color('cant get ipmi status: ' + command, 'red', 'err')
            return self.power_state
        
        if 'on' in out.decode('utf8'):
            self.power_state = True
        else:
            self.power_state = False
        return self.power_state

    def reboot(self):
        """ Under construction. """
        command = 'ipmitool -I lan -U {} -P {} -H {} power cycle'.format(
            self.ipmi_user, self.ipmi_password, self.gdevice.ip_addr_bmc)
        try:
            self.get_command_output(command)
        except OSError:
            self.power_state = False
            utility.log_color('cant reboot: ' + command, 'red', 'err')
        else:
            utility.log_color('reboot: ' + command, 'green', 'warn')

    def power_on(self):
        if not self.all_outlets_on():
            self.enable_outlets()
            time.sleep(self.BMC_STARTUP_TIME)
        # TODO wait here for outlets to on
        command = 'ipmitool -I lan -U {} -P {} -H {} power on'.format(
            self.ipmi_user, self.ipmi_password, self.gdevice.ip_addr_bmc)
        try:
            self.get_command_output(command)
        except OSError:
            self.power_state = False
            utility.log_color('cant power_on: ' + command, 'red', 'err')
        else:
            utility.log_color('power_on: ' + command, 'green', 'warn')
        self.wait_for_dev_to_ping(True, 'on')

    def soft_shutdown(self):
        # immediately set device admin status to off
        self.system_db.set_admin_status(self.gdevice.name, 'off')
        self._send_shutdown()
        time_waited = 0
        time_to_wait = 1
        while self.ping() and time_waited <= self.SYSTEMSHUTDOWN_TIMEOUT:
            time.sleep(time_to_wait)
            time_waited += time_to_wait
        time.sleep(20) # TODO
        self.hard_shutdown()

    def hard_shutdown(self):
        # immediately set device admin status to off
        self.system_db.set_admin_status(self.gdevice.name, 'off')
        self._send_ipmi_shutdown()

    def _send_shutdown(self):
        # TODO: ssh by paramico
        command = 'ssh {}@{} shutdown -h now'.format(
            self.system_user, self.gdevice.ip_addr)
        try:
            self.get_command_output(command)
        except OSError:
            utility.log_color('cant send shutdown: ' + command, 'red', 'err')

    def outlet_states(self):
        """ sdjfnkvjsdnf """
        # TODO descr
        outlet_states = {}
        for pdu_name, outlets in self.pdus.items():
            pducontroller = PDUController(pdu_name)
            outlet_states[pdu_name] = pducontroller.outlet_states(outlets)
        return outlet_states

    def wait_for_dev_to_ping(self, should_ping, adm_status):
        # TODO: refactor
        if not self.connected_to_db:
            return
        max_ping_time = 200 # s
        sleep_time = 0
        while self.ping() != should_ping and sleep_time < max_ping_time:
            time.sleep(1)
            sleep_time += 1
        self.system_db.set_admin_status(self.gdevice.name, adm_status)


    # rename
    def all_outlets_on(self):
        """ TODO """
        # TODO
        outlet_states = self.outlet_states()
        for pdu in outlet_states.values():
            for outlet in pdu:
                if not pdu[outlet]:
                    return False
        return True

    def disable_outlets(self):
        # immediately set device admin status to off
        self.system_db.set_admin_status(self.gdevice.name, 'off')
        self._command_to_outlets('off')

    def enable_outlets(self):
        self._command_to_outlets('on')

    def _command_to_outlets(self, command):
        """ Command: 'on', 'off'. """
        for pdu_name, outlets in self.pdus.items():
            pducontroller = PDUController(pdu_name)
            if command == 'off':
                pducontroller.disable_outlets(outlets)
            else:
                pducontroller.enable_outlets(outlets)

    def _send_ipmi_shutdown(self):
        command = 'ipmitool -I lan -U {} -P {} -H {} power off'.format(
            self.ipmi_user, self.ipmi_password, self.gdevice.ip_addr_bmc)
        try:
            self.get_command_output(command)
        except OSError:
            utility.log_color('cant send ipmi shutdown: ' + command, 'red', 'err')

    @staticmethod
    def get_command_output(command):
        """ Raise Error when fail """
        try:
            out = subprocess.check_output(command, shell=True, timeout=1)
        except (subprocess.CalledProcessError, subprocess.TimeoutExpired):
            raise OSError
        return out

    def connect_db(self, system_db):
        self.connected_to_db = True
        self.system_db = system_db


class PDUController(object):
    """ Should control PDU outlets. 
        Outlet number between 1 and 24 included."""
    oid_outlet = ".1.3.6.1.4.1.318.1.1.26.9.2.4.1.5."
    outlet_on = "1"
    outlet_off = "2"
    snmpget_type = "INTEGER:"
    snmpset_type = "i"
    time_to_sleep = 1

    def __init__(self, device_name):
        self.name = device_name
        self.ip_address = cfg.addressing[device_name]
        self.number_of_outlelts = 24
        self.dmanager = DownloadManager()
        assert self.oid_outlet, "wrong number of outlets"

    def is_pdu_up(self):
        """ Before command - check if device is up.
            Return: True if device is up, False if device is down.
        """
        return utility.ping(self.ip_address)

    def outlet_states(self, outlets_to_check=None):
        """ Return ordered dictionary of outlet states. 
            by default - return all states,
            if outlets_to_check specified, return only for them
            Outlet number between 1 and 24 included. """
        outlet_states = OrderedDict()
        if not outlets_to_check:
            outlets_to_check = range(1, self.number_of_outlelts + 1)
        for outlet_number in outlets_to_check:
            outlet_states[outlet_number] = self.is_power_up(outlet_number)
        return outlet_states

    def disable_outlets(self, outlets):
        for outlet_num in outlets:
            utility.log_color('Disable outlet {} at {}'.format(outlet_num, self.name), 'yellow', 'warn')
            self._send_command_to_outlet(outlet_num, 'off')
            
    def enable_outlets(self, outlets):
        for outlet_num in outlets:
            utility.log_color('Enable outlet {} at {}'.format(outlet_num, self.name), 'yellow', 'warn')
            self._send_command_to_outlet(outlet_num, 'on')

    def _send_command_to_outlet(self, outlet_num, command):
        """ Outlet num is 1-24, command is 'on' or 'off' """
        self.dmanager.snmp_set_function(
            self.ip_address, self.oid_outlet + str(outlet_num),
            self.snmpset_type,
            self.outlet_off if command == 'off' else self.outlet_on)

    def is_power_up(self, outlet_number):
        """ Return: True if outlet status is up, False otherwise.
            Outlet number between 1 and 24 included.
        """
        result = DownloadManager().snmp_get_function(
            self.ip_address,
            self.oid_outlet + str(outlet_number),
            DownloadManager.SNMP_COMMANDS['v1'])
        if result is None:
            return False
        result = result.rstrip()
        result = result.split(' ')
        if len(result) > 2:
            if str(result[-2]) == self.snmpget_type:
                if result[-1] == self.outlet_on:
                    return True
        return False

    # deprecated
    def power_on(self, outlet_number):
        """ Turn power on. """
        self.enable_outlets([outlet_number])
        return True

    # deprecated
    def power_off(self, outlet_number):
        """ Turn power off. """
        self.disable_outlets([outlet_number])
        return True

    # deprecated
    def power_on_all(self):
        """ Turn power on. """
        self.enable_outlets()

    # deprecated
    def power_off_all(self):
        """ Turn power off. """
        self.disable_outlets()

        
def power_control_action(device_name, action, context):
    """ Perform action from web. """
    utility.log_color('PowerControl: perform action: {} on {}.'.format(
        action, device_name))
    if device_name == 'all':
        for dev_name in context.devices:
            if 'BMC' in dev_name:
                power_action_on_server(dev_name, action, context)
        return
    power_action_on_server(device_name, action, context)


def power_action_on_server(device_name, action, context):
    """ Perform on, off or reboot on single BMC device. """
    timeout = 10
    if 'node' in device_name:
        ipmi_com = ["ipmitool", "-I", "lan", "-U", "root", "-P", "superuser"]
    else:
        ipmi_com = ["ipmitool", "-I", "lan", "-U", "admin", "-P", "admin"]
    ip_addr = ['-H', context.devices[device_name].ip_addr]
    command = None
    if action == 'on':
        command = ipmi_com + ip_addr + ['power', 'on']
    if action == 'off':
        command = ipmi_com + ip_addr + ['power', 'off']
    if action == 'reboot':
        command = ipmi_com + ip_addr + ['power', 'cycle']
    if command:
        print('exec:', ' '.join(command))
        utility.run_command_with_timeout(command, timeout)


def local_power_off():
    """ Emulate power off """
    # TODO: replace with real
    os.system('echo "OFFFF!"')


def local_reboot():
    """ Emulate power reboot """
    # TODO: replace with real
    os.system('echo "Rebooot!!"')
