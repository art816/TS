#!/usr/bin/env python3

# This is proprietary software.
# Part of cluster monitoring project.
# PEP8 codestyle used, python version 3.
#
# authors: dmitriy khodakov

"""  This module contain interface to task system bx.  """

import os
from collections import OrderedDict
import logging
import re

WHY_NOT_RUN = {'b': 'Недостаточно свободных процессоров'}

def read_bx_queue(filename):
    """ Return parsed dictionary in OrderedDict format.  Example: 
        { "1": {
        "content": "1_0, 1_1, 1_2\n",
        "current_waiting_time": "2",
        "max_waiting_time": "10",
        "name": "rar",
        "priority": 4,
        "tasks": 30 },
    """
    bx_out_dir = os.path.dirname(filename)
    bx_queue_dict = OrderedDict()
    with open(filename) as filed:
        filed.readline()  # first line is header
        for line in filed:
            words = line.split()
            if not words:
                break
            queue_entry_id = words[0].replace('.', '')
            queue_entry = OrderedDict()
            queue_entry['name'] = words[1]
            queue_entry['tasks'] = int(words[2])
            queue_entry['priority'] = int(words[3])
            queue_entry['current_waiting_time'] = words[4].replace('empty', 'очередь пуста')
            queue_fname = os.path.join(bx_out_dir,
                                       'bx_queue_' + queue_entry_id)
            try:
                with open(queue_fname) as queue_fd:
                    content = queue_fd.readline()
                    if 'Queue' in content:
                        content = 'очередь пуста'
                    elif 'PM' in content:
                        content = 'Не зарегистрированный способ обработки'
                    else:
                        content = content.replace('\'', '')
                        content = content.replace('[', '')
                        content = content.replace(']', '')
                    queue_entry['content'] = content
            except FileNotFoundError:
                queue_entry['content'] = 'не загружено'
            max_time = words[5].replace('(', '')
            max_time = max_time.replace(')', '')
            queue_entry['max_waiting_time'] = max_time
            bx_queue_dict[queue_entry_id] = queue_entry
    return bx_queue_dict


def parse_keys_from_string(key_regexps, string):
    """ Parse string for every regexp in key_regexp and add it by key to result.
        Return dictinary with keys as keys and results as value.
        Example: string = "aaa, bbb", key_regexps = 'a': r'(aaa)' -> {'a': a}
    """
    res = {}
    for key, regexp in key_regexps.items():
        try:
            res[key] = re.findall(regexp, string)[0]
        except IndexError:
            res[key] = None
            logging.error(
                'parse string: Cant find regexp {} in {}.'.format(
                    regexp, string))
    return res


def parse_bx_info(bx_info_raw):
    """ By given bx_info_string return dictinary like this:
        { "has_job": true,
        "jobs": [
        {
        "GPU_count": "48",
        "estimated_end": "19:45",
        "exec_time": "5",
        "job": "46.1",
        "username": "so5"
        },
        {
        "GPU_count": "21",
        "estimated_end": "20:21",
        "exec_time": "2",
        "job": "43.1",
        "username": "so4"
        } ] }
    """
    bx_info_raw = bx_info_raw.replace('No jobs executed',
                                      'Нет запущенных заявок')
    if 'Нет запущенных заявок' in bx_info_raw:
        return {'has_job': False}
    key_regexps = {'job': r'job=([\d\.]+)',
                   'username': r'username=(\w+)',
                   'GPU_count': r'GPU_count=(\d+)',
                   'exec_time': r'exec_time=(\d+)',
                   'estimated_end': r'estimated_end=([\d:]+)'}
    bx_info = {'has_job': True}
    bx_info['jobs'] = []
    for line in bx_info_raw.split('\n'):
        if line:
            job_entry = parse_keys_from_string(key_regexps, line)
            bx_info['jobs'].append(job_entry)
    return bx_info


def parse_bx_schedule(bx_info_raw):
    """ By given bx_info_string return dictinary like this:
    """
    key_regexps = {'estimated_start_in': r'estimated_start_in=([\w~]+)',
                   'time_in': r'time_in=([\d:]+)',
                   'job': r'job=([\d\.]+)',
                   'username': r'username=(\w+)',
                   'GPU_count': r'GPU_count=(\d+)', }

    bx_info_raw = bx_info_raw.replace('Job queue is empty',
                                      'Нет заявок в очереди')
    if 'Нет заявок в очереди' in bx_info_raw:
        return {'has_job': False}

    bx_schedule = {'has_job': True}
    bx_schedule['jobs'] = []
    for line in bx_info_raw.split('\n'):
        if line:
            job_entry = parse_keys_from_string(key_regexps, line)
            try:
                estimated_start_in = job_entry['estimated_start_in']
                reason, until_start = re.findall(r'(\w)~(\d+)',
                                                 estimated_start_in)[0]
                try:
                    job_entry['reason'] = WHY_NOT_RUN[reason]
                except KeyError:
                    job_entry['reason'] = reason
                job_entry['until_start'] = until_start
            except IndexError:
                job_entry['reason'] = None
                job_entry['until_start'] = None

            bx_schedule['jobs'].append(job_entry)
    return bx_schedule

def parse_bx_so_list(bx_so_raw):
    """ By given bx_so_raw return dictionary like this
        input: 1. ('rar', 40, 4)
        output: {so_list: [{'id': '1', 'name': 'rar', 'num1': '400', 'priority': '2'}]}
    """
    if 'No so' in bx_so_raw or not bx_so_raw:
        return {'has_so': False}
    so_list_res = {'has_so': True}
    so_list_res['so'] = []
    for line in bx_so_raw.split('\n'):
        if line:
            try:
                id_, name, num1, prior = re.findall(r'(\d+)\.\s*\(\'(\w+)\',\s*(\d+),\s*(\d+)', line)[0]
                so_list_res['so'].append(
                    {'id': id_, 'name': name, 'num1': num1, 'priority': prior})
            except IndexError:
                pass
    return so_list_res


def parse_bx_status(bx_status_raw):
    """ From 'Free: 5 proc.  Available: 48' return
        {'free': '5', 'available': '48'}
    """
    bx_status = {}
    try:
        free, avail = re.findall(r'Free:\s*(\d+).*Available:\s*(\d+)', bx_status_raw)[0]
        bx_status['free'] = free
        bx_status['available'] = avail
    except IndexError:
        pass
    return bx_status


def parse_file(filename, parser):
    """ Return result of parsing for contents of filename. """
    with open(filename) as filed:
        return parser(filed.read())


def read_bx_info(filename):
    """ Return information of bx current task info in dictionary format. """
    return parse_file(filename, parse_bx_info)


def read_bx_schedule(filename):
    return parse_file(filename, parse_bx_schedule)


def read_bx_so_list(filename):
    return parse_file(filename, parse_bx_so_list)

def read_bx_status(filename):
    return parse_file(filename, parse_bx_status)
