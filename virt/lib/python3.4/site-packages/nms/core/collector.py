#!/usr/bin/env python3

# This is proprietary software.
# Part of cluster monitoring project.
# PEP8 codestyle used, python version 3.
#
# authors: dmitry khodakov <dmitryhd@gmail.com>

""" Collecting data from varios devices and computers
    granting common interface to all gathered data.
"""

import time
import datetime
from operator import attrgetter

import nms.config as cfg
from nms.core.alert_handler import AlertHandler
from nms.core.download import DownloadManager
import nms.core.database as db
import nms.utility as utility


class Collector:
    """ Regularly collecting data from various devices. """

    def __init__(self, db_name, context, period=cfg.COLLECT_INTERVAL):
        self.period = period  # in seconds
        self.session_manager = db.SessionManager(db_name)
        self.db_op_collected = db.CollectedDataOperator(self.session_manager)
        self.db_op_collected.create_tables(context.devices)
        self.db_op_system = db.SystemDataOperator(self.session_manager)
        self.db_op_system.create_tables(context.general_devices)
        self.alert_handler = AlertHandler(self.session_manager)
        self.dmanager = DownloadManager()
        self.context = context

    def log_collected(self, dev_list, only_dev=None):
        for device in dev_list:
            if not only_dev or device.name in only_dev:
                utility.log_color( device.name, 'cyan', 'info')
                for param in device.params_dict.values():
                    param_str = '\t%20s\t%s' % (param.name, param.value)
                    utility.log_color(
                        param_str, 'red' if param.value is None else 'green',
                        'info')

    def collect(self, dev_list, cur_time):
        """ Main function, will be runned in loop to gather and store
            collector data.
            * dev_list is list of devices.
            * cur_time is int.
        """
        utility.log_color(
            'Calling collect: {}'.format(datetime.datetime.now()), 'green')
        self.set_device_online_status(dev_list)
        self.download_from_devices(dev_list, cur_time)
        self.reset_offline_device_params(dev_list)
        for device in dev_list:
            device.calculate_parameters()
        self.log_collected(dev_list)
        self.alert_handler.update_alerts(dev_list)
        self.db_op_collected.save_data(cur_time, dev_list, True)

    def set_device_online_status(self, dev_list):
        """ Ping all devices in list and set corresponding statuses
            for all devices.
        """
        online_states = utility.group_ping(dev_list)
        for device, online_state in zip(dev_list, online_states):
            device.is_online = online_state
            if 'online' in device.params_dict:
                device.params_dict['online'].value = online_state
            if 'online_bmc' in device.params_dict:
                device.params_dict['online_bmc'].value = online_state
            # TODO: change it, very ugly hack for switch
            if device.name == 'switch':
                device.params_dict['online'].value = True
                device.is_online = True
    
        for g_dev in self.context.general_devices.values():
            g_dev.set_online_status()
        self.db_op_system.save_devices_online_status(
            self.context.general_devices)

    @staticmethod
    def reset_offline_device_params(dev_list):
        """ Set all parameters of device in dev_list to None, if
            it is offline.
        """
        for device in dev_list:
            if not device.is_online:
                for param in device.params_dict.values():
                    if 'online' not in param.name:
                        param.value = None

    def download_from_devices(self, devices, cur_time):
        """ Download data to all parameters of devices.
            Paralleled by devices.
        """
        process_runner = utility.ProcessRunner(cfg.DEFAULT_RUNNER_TIMEOUT)
        for device in devices:
            if device.is_online:
                params_to_collect = self.get_parameters_to_collect(
                    device, cur_time)
                #utility.log_color('from {} to collect: {}'.format(device.name, params_to_collect), 'yellow', 'warning')
                if not params_to_collect:
                    # no data should be collected this time on this device
                    continue
                process_runner.add(
                    self.dmanager.download_multiple_params,
                    [device, params_to_collect])
        result = process_runner.run()
        # TODO;
        for dev in devices:
            if dev.name not in result:
                for param in dev.params_dict.values():
                    param.value = None

        for dev_name in result:
            for param in result[dev_name]:
                self.context.devices[dev_name].params_dict[
                    param.name].value = param.value

    def collector_loop(self, dev_names=None, times=-1):
        """ Gather parameters from all devices, listed in dev_names
            every period seconds, 'times' times.
            Store parameters in database db_operator.
            If dev_names=[](default), gather from all devices.
        """
        if dev_names:
            dev_list = [self.context.devices[dname] for dname
                        in self.context.devices if dname in dev_names]
        else:
            dev_list = list(self.context.devices.values())
        dev_list.sort(key=attrgetter('name'))
        while True:
            cur_time = utility.get_current_int_time()
            self.collect(dev_list, cur_time)
            if times < 0:  # if times = -1 - infinite loop
                time.sleep(self.period)
                continue
            times -= 1
            if times <= 0:
                break
            time.sleep(self.period)

    @staticmethod
    def get_parameters_to_collect(device, cur_time):
        """ Return list of parameters, which need to be collected for given
            device according to param.last_collected and
            param.collect_interval, based on current time.

            Updates parameters.last_collected time!
        """
        params_to_collect = []
        for param in device.params_dict.values():
            data_age = cur_time - param.last_collected
            do_need_to_collect = data_age >= param.collect_interval
            if not param.last_collected or do_need_to_collect:
                params_to_collect.append(param)
        for param in params_to_collect:
            param.last_collected = cur_time

        #utility.log_color('decided to collect from {}: {}'.format(
        #    device.name, params_to_collect), 'yellow', 'debug')
        return params_to_collect
