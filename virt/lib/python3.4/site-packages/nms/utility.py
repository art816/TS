#!/usr/bin/env python3

# This is proprietary software.
# Part of cluster monitoring project.
# PEP8 codestyle used, python version 3.
#
# authors: dmitry khodakov <dmitryhd@gmail.com>
# date: 29.10.2014
#
# pylint: disable=W0142

""" Contains various utility functions. """

import logging
import logging.handlers
import re
import time
import sys
import datetime
from os import waitpid
from subprocess import PIPE, Popen, SubprocessError
from threading import Thread, Timer
import argparse
from colorama import Fore
import multiprocessing as mp

import nms
import nms.config as cfg


LOG = None


def log_color(message, color='red', level='debug'):
    """ Print in log. Example: log_color('xxxx', 'red', 'err')"""
    levels = {'err': logging.ERROR,
              'warn': logging.WARNING,
              'warning': logging.WARNING,

              'info': logging.INFO,
              'debug': logging.DEBUG, 'debug2': 9, 'debug3': 8}
    log = logging.getLogger(cfg.LOG_NAME)
    colors = {'red': Fore.RED, 'green': Fore.GREEN, 'blue': Fore.BLUE,
              'cyan': Fore.CYAN, 'yellow': Fore.YELLOW}
    log.log(levels[level], colors[color] + message + Fore.RESET)


class ProcessRunner(object):
    """ Can store commands and tun them in parallel. Example of usage:
        process_runner = utility.ProcessRunner()
        for device in devices:
            process_runner.add(dmanager.download_multiple_params,
                               [device, 11])
        result = process_runner.run()
    """
    # TODO: example of usage here
    def __init__(self, timeout=cfg.DEFAULT_RUNNER_TIMEOUT):
        self.processes = []
        self.functions = []
        self.arguments = []
        self.timeout = timeout
        self.queues = []

    def add(self, function, func_arguments):
        """ Add command to runner. """
        self.functions.append(function)
        self.arguments.append(func_arguments)

    def create_processes(self):
        """ Initialize processes before running. """
        self.processes = []
        self.queues = []
        _id = 0
        for func, args in zip(self.functions, self.arguments):
            self.queues.append(mp.Queue())
            self.processes.append(mp.Process(
                target=self.get_output_of_function,
                args=(func, args, self.queues[_id])))
            _id += 1

    def get_output(self):
        """ return dictionary """
        # TODO: if funciton failed - result wont be in output
        results = [queue.get() for queue in self.queues]
        output = {}
        for result in results:
            if result is None:
                continue
            device_name, parameters = result
            output[device_name] = parameters
        return output

    @staticmethod
    def get_output_of_function(function, args, queue):
        """ Can save output of given funtion to queue. """
        output = function(*args)
        log_color('Get output :' + str(output), 'blue', 'debug')
        queue.put(output)

    def wait_for_processes(self):
        """ Wait for all child to terminate or self.timeout. """
        start = time.time()
        while time.time() - start <= self.timeout:
            if any(proc.is_alive() for proc in self.processes):
                time.sleep(.1)  # Just to avoid hogging the CPU
            else:
                # All the processes are done, break now.
                break
        else:
            # We only enter this if we didn't 'break' above.
            print("timed out, killing all processes")
            for proc in self.processes:
                print('joining process {}'.format(proc))
                proc.terminate()
                proc.join()

    def run(self):
        """ Run all processes. """
        self.create_processes()
        for proc in self.processes:
            proc.start()
        self.wait_for_processes()
        return self.get_output()


class LogCreator(object):
    """ Borg like object, must return log handler.  """
    __shared_state = {}
    log = None

    def __init__(self):
        self.__dict__ = self.__shared_state
        module_name = cfg.LOG_NAME
        if not self.log:
            self.log = logging.getLogger(module_name)
            file_handler = logging.handlers.RotatingFileHandler(
                cfg.LOG_PATH + module_name + '.log', backupCount=1,
                maxBytes=cfg.LOG_MAX_SIZE)
            formatter = logging.Formatter(cfg.LOG_FORMAT)
            file_handler.setFormatter(formatter)
            self.log.addHandler(file_handler)
            stdout_handler = logging.StreamHandler()
            self.log.addHandler(stdout_handler)
            self.log.setLevel(cfg.CUR_LOG_LEVEL)

    def set_log_level(self, level):
        """ Specify log level. """
        self.log.setLevel(level)

    def get_log(self):
        """ Return log instance. """
        return self.log


def parse_args():
    """ Process command line arguments. """
    parser = argparse.ArgumentParser()
    parser.add_argument("-v", "--version", dest="show_version",
                        action='store_const', const=True, default=False,
                        help='show version and exit')
    parser.add_argument("-p", "--project_name", type=str,
                        help=("localhost, burka, bussol, buer. "
                              "Default - " +  cfg.SYSTEM_NAME),
                              default=cfg.SYSTEM_NAME)
    parser.add_argument("-t", "--time_interval", type=int,
                        help="in seconds",
                        default=cfg.COLLECT_INTERVAL)
    parser.add_argument("-l", "--log_level", type=int,
                        help="1: Error, 2: Warning, 3: Info, 4: Debug",
                        default=2)
    parser.add_argument("-c", "--total_num_of_tries", type=int,
                        help="Number of tries", default=-1)
    parser.add_argument("-d", "--db_name", type=str,
                        help="database name")
    args = parser.parse_args()

    if args.show_version:
        print('Version:', nms.__version__,
              'release_date:', nms.__release_date__)
        sys.exit(0)

    if args.log_level:
        log_level_dict = {1: logging.ERROR, 2: logging.WARNING,
                          3: logging.INFO, 4: logging.DEBUG}
        args.log_level = log_level_dict[args.log_level]
        log_creator = LogCreator()
        log_creator.set_log_level(args.log_level)
    if not args.db_name:
        args.db_name = cfg.CONTEXT_DB[args.project_name]
    return args


def run_command_with_timeout(command, timeinterval):
    """ return result """
    # TODO: rewritet
    def timeout(proc, command):
        """ Wait for other process here. """
        if proc.poll() == None:
            try:
                proc.kill()
            except RuntimeError:
                pass

    # disable error output by : stderr=PIPE
    process = Popen(command, stdout=PIPE, stderr=PIPE)
    timer = Timer(timeinterval, timeout, [process, ' '.join(command)])
    timer.start()
    waitpid(process.pid, 0)
    # process.wait()
    try:
        output = process.communicate()[0]
        output = output.decode("utf-8")
    except (SubprocessError, UnicodeDecodeError):
        output = None
    timer.cancel()
    return output


def ping(address, timeout=None):
    """ Standalone funtion to check if address is up.
        Return True if up, False otherwise """
    if timeout == None:
        timeout = cfg.PING_TIMEOUT
    result = run_command_with_timeout(['ping', '-W', '1', '-c', '1', address],
                                      timeout)
    rematch = re.search(r"(\d+) received,", result)
    packets = '0'
    if rematch:
        packets = rematch.groups()[0]
    return packets != '0'


def group_ping(dev_list):
    """ Static function for ping all nodes in monitoring domain
        return: list of True or False in place of device in addressing map
    """
    ping_list = [False] * len(dev_list)

    def _ping(address, index):
        """ just ping specified address and store result in list """
        ping_list[index] = ping(address)

    functions = [_ping] * len(dev_list)
    args = []
    index = 0
    for dev in dev_list:
        args.append([dev.ip_addr, index])
        index += 1
    run_in_parallel(functions, args)
    return ping_list


def run_in_parallel_with_res(functions, args=None):
    """ Static function for ping all nodes in monitoring domain
        return: list of True or False in place of device in addressing
    """
    # TODO: add here timeout
    result_list = [None] * len(functions)

    def _run_function_and_save_result(index, function, arguments=None):
        """ just ping specified address and store result in list """
        if not arguments:
            result_list[index] = function()
        else:
            result_list[index] = function(*arguments)

    index = 0
    additional_args = []
    additional_functions = [_run_function_and_save_result] * len(functions)
    for func in functions:
        if not args:
            additional_args.append([index, func])
        else:
            additional_args.append([index, func, args[index]])
        index += 1
    run_in_parallel(additional_functions, additional_args)
    return result_list


def run_in_parallel(functions, arg=None):
    """ Should run multiple functions in thread, and wait for all of them
        arg is list of list
    """
    # TODO: add here timeout merge with run parallel
    if not functions:
        return
    threads = []
    index = 0
    for function in functions:
        if arg:
            thread = Thread(target=function, args=arg[index])
        else:
            thread = Thread(target=function)
        thread.start()
        threads.append(thread)
        index += 1
    for thread in threads:
        thread.join()


def time_to_int(time_value):
    """ Convert datetime time to integer value. """
    return int(time.mktime(time_value.timetuple()))


def get_current_int_time():
    """ Return current utc+0 time in integer form. """
    return int(time.time() + time.timezone)


def one_day_before(timeval):
    """ Return date, than one day before given value in integer form. """
    return timeval - 24*60*60


def time_to_str(timestamp):
    """ Given int time, return str time. """
    return datetime.datetime.fromtimestamp(timestamp).strftime(
        cfg.TIME_FORMAT)


def convert_value_to_right_type(type_, value):
    """ Return value in right form or None. """
    types = {'str': str, 'int': int, 'float': float}
    if value is None:
        return value
    try:
        value = types[type_](value)
    except (ValueError, TypeError):
        try:
            value = float(value)
        except (ValueError, TypeError):
            value = None
    return value


def parse_hosts():
    """ Return dictionary: hostname -> ip_address. """
    host_address = {}
    for line in open('/etc/hosts').readlines():
        if line[0] != '#':
            try:
                ip_addr = re.search(r'(\d+.\d+.\d+.\d+)', line).groups()[0]
                host = re.search(r'([.\w-]*)$', line).groups()[0]
                host_address[host] = ip_addr
            except AttributeError:
                pass
    return host_address


def save_float_conversion(arg):
    """ Convert value to float, or to None. """
    try:
        res = float(arg)
    except TypeError:
        res = None
    return res


def to_general_device(device_name):
    """ Return general device name by device name
    """
    return device_name.replace('BMC', '')


def to_device(gdev, param_name):
    """ Find device in general device with param_name or return None. """
    for device in gdev.devices:
        if param_name in device.params_dict:
            return device.name
    return None

